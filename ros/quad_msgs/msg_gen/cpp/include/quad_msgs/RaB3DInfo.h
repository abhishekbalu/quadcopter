/* Auto-generated by genmsg_cpp for file /home/ubuntu/ros/quad_control_rosbuild/quad_msgs/msg/RaB3DInfo.msg */
#ifndef QUAD_MSGS_MESSAGE_RAB3DINFO_H
#define QUAD_MSGS_MESSAGE_RAB3DINFO_H
#include <string>
#include <vector>
#include <map>
#include <ostream>
#include "ros/serialization.h"
#include "ros/builtin_message_traits.h"
#include "ros/message_operations.h"
#include "ros/time.h"

#include "ros/macros.h"

#include "ros/assert.h"


namespace quad_msgs
{
template <class ContainerAllocator>
struct RaB3DInfo_ {
  typedef RaB3DInfo_<ContainerAllocator> Type;

  RaB3DInfo_()
  : rn(0)
  , x()
  , r()
  , f()
  , bn()
  , s_it()
  , s_ot()
  , g()
  , dg()
  {
  }

  RaB3DInfo_(const ContainerAllocator& _alloc)
  : rn(0)
  , x(_alloc)
  , r(_alloc)
  , f(_alloc)
  , bn(_alloc)
  , s_it(_alloc)
  , s_ot(_alloc)
  , g(_alloc)
  , dg(_alloc)
  {
  }

  typedef int8_t _rn_type;
  int8_t rn;

  typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _x_type;
  std::vector<double, typename ContainerAllocator::template rebind<double>::other >  x;

  typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _r_type;
  std::vector<double, typename ContainerAllocator::template rebind<double>::other >  r;

  typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _f_type;
  std::vector<double, typename ContainerAllocator::template rebind<double>::other >  f;

  typedef std::vector<int8_t, typename ContainerAllocator::template rebind<int8_t>::other >  _bn_type;
  std::vector<int8_t, typename ContainerAllocator::template rebind<int8_t>::other >  bn;

  typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _s_it_type;
  std::vector<double, typename ContainerAllocator::template rebind<double>::other >  s_it;

  typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _s_ot_type;
  std::vector<double, typename ContainerAllocator::template rebind<double>::other >  s_ot;

  typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _g_type;
  std::vector<double, typename ContainerAllocator::template rebind<double>::other >  g;

  typedef std::vector<double, typename ContainerAllocator::template rebind<double>::other >  _dg_type;
  std::vector<double, typename ContainerAllocator::template rebind<double>::other >  dg;


  typedef boost::shared_ptr< ::quad_msgs::RaB3DInfo_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::quad_msgs::RaB3DInfo_<ContainerAllocator>  const> ConstPtr;
}; // struct RaB3DInfo
typedef  ::quad_msgs::RaB3DInfo_<std::allocator<void> > RaB3DInfo;

typedef boost::shared_ptr< ::quad_msgs::RaB3DInfo> RaB3DInfoPtr;
typedef boost::shared_ptr< ::quad_msgs::RaB3DInfo const> RaB3DInfoConstPtr;


template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const  ::quad_msgs::RaB3DInfo_<ContainerAllocator> & v)
{
  ros::message_operations::Printer< ::quad_msgs::RaB3DInfo_<ContainerAllocator> >::stream(s, "", v);
  return s;}

} // namespace quad_msgs

namespace ros
{
namespace message_traits
{
template<class ContainerAllocator> struct IsMessage< ::quad_msgs::RaB3DInfo_<ContainerAllocator> > : public TrueType {};
template<class ContainerAllocator> struct IsMessage< ::quad_msgs::RaB3DInfo_<ContainerAllocator>  const> : public TrueType {};
template<class ContainerAllocator>
struct MD5Sum< ::quad_msgs::RaB3DInfo_<ContainerAllocator> > {
  static const char* value() 
  {
    return "c790f3254d49f5ebaa93fd6a486300eb";
  }

  static const char* value(const  ::quad_msgs::RaB3DInfo_<ContainerAllocator> &) { return value(); } 
  static const uint64_t static_value1 = 0xc790f3254d49f5ebULL;
  static const uint64_t static_value2 = 0xaa93fd6a486300ebULL;
};

template<class ContainerAllocator>
struct DataType< ::quad_msgs::RaB3DInfo_<ContainerAllocator> > {
  static const char* value() 
  {
    return "quad_msgs/RaB3DInfo";
  }

  static const char* value(const  ::quad_msgs::RaB3DInfo_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct Definition< ::quad_msgs::RaB3DInfo_<ContainerAllocator> > {
  static const char* value() 
  {
    return "#Number of receivers\n\
int8 rn\n\
\n\
#Receivers positions - (x,y,z) coordinates of each receiver are contiguous in memory\n\
float64[] x\n\
\n\
#Receiver headings - (x,y,z) coordinates of the headings are contiguous in memory\n\
#(do we need to convert the positions back to a normal (x,y,z) reference frame?)\n\
float64[] r\n\
\n\
#Absorption coefficient model parameters - they are contiguous in memory for each receiver\n\
float64[] f\n\
\n\
#Number of branches of the amplification stage model (depends of each receiver)\n\
int8[] bn\n\
\n\
#The transitions that define each branch of the amplification stage model\n\
float64[] s_it #inputs\n\
float64[] s_ot #outputs\n\
\n\
#Amplication stage model parameters - they are contiguous in memeory for each branch (going from s_i^0 to s_i^2). The branches are in ascending order\n\
#All parameters for each receiver are contiguous in memeory\n\
float64[] g #model\n\
float64[] dg #derivatives\n\
\n\
";
  }

  static const char* value(const  ::quad_msgs::RaB3DInfo_<ContainerAllocator> &) { return value(); } 
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

template<class ContainerAllocator> struct Serializer< ::quad_msgs::RaB3DInfo_<ContainerAllocator> >
{
  template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
  {
    stream.next(m.rn);
    stream.next(m.x);
    stream.next(m.r);
    stream.next(m.f);
    stream.next(m.bn);
    stream.next(m.s_it);
    stream.next(m.s_ot);
    stream.next(m.g);
    stream.next(m.dg);
  }

  ROS_DECLARE_ALLINONE_SERIALIZER;
}; // struct RaB3DInfo_
} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::quad_msgs::RaB3DInfo_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const  ::quad_msgs::RaB3DInfo_<ContainerAllocator> & v) 
  {
    s << indent << "rn: ";
    Printer<int8_t>::stream(s, indent + "  ", v.rn);
    s << indent << "x[]" << std::endl;
    for (size_t i = 0; i < v.x.size(); ++i)
    {
      s << indent << "  x[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.x[i]);
    }
    s << indent << "r[]" << std::endl;
    for (size_t i = 0; i < v.r.size(); ++i)
    {
      s << indent << "  r[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.r[i]);
    }
    s << indent << "f[]" << std::endl;
    for (size_t i = 0; i < v.f.size(); ++i)
    {
      s << indent << "  f[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.f[i]);
    }
    s << indent << "bn[]" << std::endl;
    for (size_t i = 0; i < v.bn.size(); ++i)
    {
      s << indent << "  bn[" << i << "]: ";
      Printer<int8_t>::stream(s, indent + "  ", v.bn[i]);
    }
    s << indent << "s_it[]" << std::endl;
    for (size_t i = 0; i < v.s_it.size(); ++i)
    {
      s << indent << "  s_it[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.s_it[i]);
    }
    s << indent << "s_ot[]" << std::endl;
    for (size_t i = 0; i < v.s_ot.size(); ++i)
    {
      s << indent << "  s_ot[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.s_ot[i]);
    }
    s << indent << "g[]" << std::endl;
    for (size_t i = 0; i < v.g.size(); ++i)
    {
      s << indent << "  g[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.g[i]);
    }
    s << indent << "dg[]" << std::endl;
    for (size_t i = 0; i < v.dg.size(); ++i)
    {
      s << indent << "  dg[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.dg[i]);
    }
  }
};


} // namespace message_operations
} // namespace ros

#endif // QUAD_MSGS_MESSAGE_RAB3DINFO_H

